diff --git a/build_scripts/platforms/unix.py b/build_scripts/platforms/unix.py
index abca942b..fcbd010e 100644
--- a/build_scripts/platforms/unix.py
+++ b/build_scripts/platforms/unix.py
@@ -144,8 +144,8 @@ def prepare_packages_posix(self, vars):
             executables.extend(copydir(
                 "{install_dir}/bin/Designer.app",
                 "{st_build_dir}/{st_package_name}/Designer.app",
-                filter=None,
-                recursive=True, vars=vars))
+                filter=None, recursive=True,
+                force=False, vars=vars))
         else:
             copyfile(
                 "{install_dir}/bin/designer",
diff --git a/coin_build_instructions.py b/coin_build_instructions.py
index 95bd4eba..325b02de 100644
--- a/coin_build_instructions.py
+++ b/coin_build_instructions.py
@@ -112,7 +112,8 @@ def call_setup(python_ver, phase):
         run_instruction(["virtualenv", "-p", _pExe,  _env], "Failed to create virtualenv")
         # When the 'python_ver' variable is empty, we are using Python 2
         # setuptools from v45+ removed the support for Python 2, so we pin an old release
-        install_pip_dependencies(env_pip, ["pip", "numpy",
+        install_pip_dependencies(env_pip, ["pip",
+                                           "numpy" if python_ver else "numpy==1.16.6",
                                            "setuptools" if python_ver else "setuptools==44.0.0",
                                            "sphinx", "six", "wheel"])
 
diff --git a/dist/changes-5.14.2.1 b/dist/changes-5.14.2.1
new file mode 100644
index 00000000..71a87348
--- /dev/null
+++ b/dist/changes-5.14.2.1
@@ -0,0 +1,32 @@
+Qt for Python 5.14.2.1 is a bug-fix release.
+
+For more details, refer to the online documentation included in this
+distribution. The documentation is also available online:
+
+https://doc.qt.io/qtforpython/
+
+Some of the changes listed in this file include issue tracking numbers
+corresponding to tasks in the Qt Bug Tracker:
+
+https://bugreports.qt.io/
+
+Each of these identifiers can be entered in the bug tracker to obtain more
+information about a particular change.
+
+****************************************************************************
+*                                  PySide2                                 *
+****************************************************************************
+
+
+ - [PYSIDE-841] Add an example for QUiLoader
+ - [PYSIDE-1253] Fix lockups in QMetaObject.invokeMethod with
+                 BlockingQueuedConnection
+
+****************************************************************************
+*                                  Shiboken2                               *
+****************************************************************************
+
+ - [PYSIDE-813] Fix race condition with unprotected Py_INCREFs
+ - [PYSIDE-1255] Fix Qt properties not working in classes inheriting QObject
+ - [PYSIDE-1259] Support Clang version 10
+ - [PYSIDE-1266] Fix documentation error in "Getting Started"
diff --git a/examples/uiloader/uiloader.py b/examples/uiloader/uiloader.py
new file mode 100644
index 00000000..1e6e72d7
--- /dev/null
+++ b/examples/uiloader/uiloader.py
@@ -0,0 +1,71 @@
+#############################################################################
+##
+## Copyright (C) 2020 The Qt Company Ltd.
+## Contact: http://www.qt.io/licensing/
+##
+## This file is part of the Qt for Python examples of the Qt Toolkit.
+##
+## $QT_BEGIN_LICENSE:BSD$
+## You may use this file under the terms of the BSD license as follows:
+##
+## "Redistribution and use in source and binary forms, with or without
+## modification, are permitted provided that the following conditions are
+## met:
+##   * Redistributions of source code must retain the above copyright
+##     notice, this list of conditions and the following disclaimer.
+##   * Redistributions in binary form must reproduce the above copyright
+##     notice, this list of conditions and the following disclaimer in
+##     the documentation and/or other materials provided with the
+##     distribution.
+##   * Neither the name of The Qt Company Ltd nor the names of its
+##     contributors may be used to endorse or promote products derived
+##     from this software without specific prior written permission.
+##
+##
+## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+## "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+## LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+## A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+## OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+## SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+## LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+## DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+## THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+## (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+## OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+##
+## $QT_END_LICENSE$
+##
+#############################################################################
+
+"""QUiLoader example, showing how to dynamically load a Qt Designer form
+   from a UI file."""
+
+from argparse import ArgumentParser, RawTextHelpFormatter
+import sys
+
+from PySide2.QtCore import Qt, QFile, QIODevice
+from PySide2.QtWidgets import QApplication, QWidget
+from PySide2.QtUiTools import QUiLoader
+
+
+if __name__ == '__main__':
+    arg_parser = ArgumentParser(description="QUiLoader example",
+                                formatter_class=RawTextHelpFormatter)
+    arg_parser.add_argument('file', type=str, help='UI file')
+    args = arg_parser.parse_args()
+    ui_file_name = args.file
+
+    app = QApplication(sys.argv)
+    ui_file = QFile(ui_file_name)
+    if not ui_file.open(QIODevice.ReadOnly):
+        print("Cannot open {}: {}".format(ui_file_name, ui_file.errorString()))
+        sys.exit(-1)
+    loader = QUiLoader()
+    widget = loader.load(ui_file, None)
+    ui_file.close()
+    if not widget:
+        print(loader.errorString())
+        sys.exit(-1)
+    widget.show()
+    sys.exit(app.exec_())
diff --git a/sources/pyside2/PySide2/QtCore/typesystem_core_common.xml b/sources/pyside2/PySide2/QtCore/typesystem_core_common.xml
index f64a8fd7..b418d268 100644
--- a/sources/pyside2/PySide2/QtCore/typesystem_core_common.xml
+++ b/sources/pyside2/PySide2/QtCore/typesystem_core_common.xml
@@ -2885,6 +2885,7 @@
       <object-type name="Connection">
         <include file-name="qobjectdefs.h" location="global"/>
       </object-type>
+    <modify-function signature="^invokeMethod\(" allow-thread="yes"/>
   </object-type>
   <value-type name="QMetaProperty" >
     <!-- This isn't part of Qt public API -->
diff --git a/sources/pyside2/PySide2/QtQuick/typesystem_quick.xml b/sources/pyside2/PySide2/QtQuick/typesystem_quick.xml
index 12c1ac33..223eff77 100644
--- a/sources/pyside2/PySide2/QtQuick/typesystem_quick.xml
+++ b/sources/pyside2/PySide2/QtQuick/typesystem_quick.xml
@@ -64,7 +64,7 @@
     <object-type name="QQuickImageResponse" since="5.6"/>
 
     <object-type name="QQuickTransform"/>
-    <object-type name="QQuickItem" delete-in-main-thread="true" no-override-caching="true">
+    <object-type name="QQuickItem" delete-in-main-thread="true">
         <value-type name="UpdatePaintNodeData"/>
         <enum-type name="Flag" flags="Flags"/>
         <enum-type name="ItemChange"/>
diff --git a/sources/pyside2/PySide2/glue/qtcore.cpp b/sources/pyside2/PySide2/glue/qtcore.cpp
index 60ddf675..169b89ca 100644
--- a/sources/pyside2/PySide2/glue/qtcore.cpp
+++ b/sources/pyside2/PySide2/glue/qtcore.cpp
@@ -1685,7 +1685,7 @@ Py_UNICODE *unicode = PyUnicode_AS_UNICODE(%in);
 // cast as Py_UNICODE can be a different type
 %out = QString::fromUcs4((const uint *)unicode);
 # else
-%out = QString::fromUtf16((const ushort *)unicode, PyUnicode_GET_SIZE(%in));
+%out = QString::fromUtf16((const ushort *)unicode, PepUnicode_GetLength(%in));
 # endif
 #else
 wchar_t *temp = PyUnicode_AsWideCharString(%in, NULL);
diff --git a/sources/pyside2/doc/pyside-examples/examples.qdoc b/sources/pyside2/doc/pyside-examples/examples.qdoc
index d82b33cf..748c4f8f 100644
--- a/sources/pyside2/doc/pyside-examples/examples.qdoc
+++ b/sources/pyside2/doc/pyside-examples/examples.qdoc
@@ -28,5 +28,10 @@
 /*!
     \group all-pyside-examples
     \title All Qt for Python Examples
-    \brief A list of all the examples that are available with the Qt for Python package.
+    \brief A varied selection of examples can be found in the 'examples' directory of the
+    pyside-setup repository. This can be accessed after installing
+    PySide2 via pip, checking the 'site-packages/PySide2/examples' directory.
+
+    This page aims to document the most important use cases of the module
+    and it will be extended with each release.
 */
diff --git a/sources/pyside2/doc/tutorials/basictutorial/uifiles.rst b/sources/pyside2/doc/tutorials/basictutorial/uifiles.rst
index a45bfc18..2c0178e2 100644
--- a/sources/pyside2/doc/tutorials/basictutorial/uifiles.rst
+++ b/sources/pyside2/doc/tutorials/basictutorial/uifiles.rst
@@ -163,12 +163,17 @@ The complete code of this example looks like this:
     if __name__ == "__main__":
         app = QApplication(sys.argv)
 
-        ui_file = QFile("mainwindow.ui")
-        ui_file.open(QFile.ReadOnly)
-
+        ui_file_name = "mainwindow.ui"
+        ui_file = QFile(ui_file_name)
+        if not ui_file.open(QIODevice.ReadOnly):
+            print("Cannot open {}: {}".format(ui_file_name, ui_file.errorString()))
+            sys.exit(-1)
         loader = QUiLoader()
         window = loader.load(ui_file)
         ui_file.close()
+        if not window:
+            print(loader.errorString())
+            sys.exit(-1)
         window.show()
 
         sys.exit(app.exec_())
diff --git a/sources/pyside2/libpyside/dynamicqmetaobject.cpp b/sources/pyside2/libpyside/dynamicqmetaobject.cpp
index 51e6598b..dae9e205 100644
--- a/sources/pyside2/libpyside/dynamicqmetaobject.cpp
+++ b/sources/pyside2/libpyside/dynamicqmetaobject.cpp
@@ -140,7 +140,8 @@ MetaObjectBuilder::MetaObjectBuilder(PyTypeObject *type, const QMetaObject *meta
 
 MetaObjectBuilder::~MetaObjectBuilder()
 {
-    qDeleteAll(m_d->m_cachedMetaObjects);
+    for (auto *metaObject : m_d->m_cachedMetaObjects)
+        free(const_cast<QMetaObject*>(metaObject));
     delete m_d->m_builder;
     delete m_d;
 }
diff --git a/sources/pyside2/libpyside/signalmanager.cpp b/sources/pyside2/libpyside/signalmanager.cpp
index 01b347a3..8e8cc9f0 100644
--- a/sources/pyside2/libpyside/signalmanager.cpp
+++ b/sources/pyside2/libpyside/signalmanager.cpp
@@ -114,18 +114,24 @@ namespace PySide {
 PyObjectWrapper::PyObjectWrapper()
     :m_me(Py_None)
 {
+    // PYSIDE-813: When PYSIDE-164 was solved by adding some thread allowance,
+    // this code was no longer protected. It was hard to find this connection.
+    // See the website https://bugreports.qt.io/browse/PYSIDE-813 for details.
+    Shiboken::GilState gil;
     Py_XINCREF(m_me);
 }
 
 PyObjectWrapper::PyObjectWrapper(PyObject *me)
     : m_me(me)
 {
+    Shiboken::GilState gil;
     Py_XINCREF(m_me);
 }
 
 PyObjectWrapper::PyObjectWrapper(const PyObjectWrapper &other)
     : m_me(other.m_me)
 {
+    Shiboken::GilState gil;
     Py_XINCREF(m_me);
 }
 
@@ -142,6 +148,7 @@ PyObjectWrapper::~PyObjectWrapper()
 
 void PyObjectWrapper::reset(PyObject *o)
 {
+    Shiboken::GilState gil;
     Py_XINCREF(o);
     Py_XDECREF(m_me);
     m_me = o;
@@ -559,7 +566,10 @@ static MetaObjectBuilder *metaBuilderFromDict(PyObject *dict)
     if (!dict || !PyDict_Contains(dict, metaObjectAttr))
         return nullptr;
 
-    PyObject *pyBuilder = PyDict_GetItem(dict, metaObjectAttr);
+    // PYSIDE-813: The above assumption is not true in debug mode:
+    // PyDict_GetItem would touch PyThreadState_GET and the global error state.
+    // PyDict_GetItemWithError instead can work without GIL.
+    PyObject *pyBuilder = PyDict_GetItemWithError(dict, metaObjectAttr);
 #ifdef IS_PY3K
     return reinterpret_cast<MetaObjectBuilder *>(PyCapsule_GetPointer(pyBuilder, nullptr));
 #else
diff --git a/sources/pyside2/libpyside/signalmanager.h b/sources/pyside2/libpyside/signalmanager.h
index 229ddb91..fe077bd1 100644
--- a/sources/pyside2/libpyside/signalmanager.h
+++ b/sources/pyside2/libpyside/signalmanager.h
@@ -43,6 +43,7 @@
 #include "pysidemacros.h"
 
 #include <sbkpython.h>
+#include <shibokenmacros.h>
 
 #include <QtCore/QMetaMethod>
 
diff --git a/sources/pyside2/pyside_version.py b/sources/pyside2/pyside_version.py
index 53ec8336..fc04d00a 100644
--- a/sources/pyside2/pyside_version.py
+++ b/sources/pyside2/pyside_version.py
@@ -39,7 +39,7 @@
 
 major_version = "5"
 minor_version = "14"
-patch_version = "2"
+patch_version = "2.1"
 
 # For example: "a", "b", "rc"
 # (which means "alpha", "beta", "release candidate").
diff --git a/sources/pyside2/tests/QtCore/versioninfo_test.py b/sources/pyside2/tests/QtCore/versioninfo_test.py
index c682dbbd..8b93fde8 100644
--- a/sources/pyside2/tests/QtCore/versioninfo_test.py
+++ b/sources/pyside2/tests/QtCore/versioninfo_test.py
@@ -44,7 +44,7 @@ class TestVersionInfo(unittest.TestCase):
         self.assertEqual(len(v), 5)
         self.assertEqual(type(v[0]), int)
         self.assertEqual(type(v[1]), int)
-        self.assertEqual(type(v[2]), int)
+        #self.assertEqual(type(v[2]), int)  disabled for 5.14.2.1 fix
         self.assertEqual(type(v[3]), str)
         self.assertEqual(type(v[4]), str)
 
diff --git a/sources/pyside2/tests/pysidetest/CMakeLists.txt b/sources/pyside2/tests/pysidetest/CMakeLists.txt
index 3ba2ad29..46a8023c 100644
--- a/sources/pyside2/tests/pysidetest/CMakeLists.txt
+++ b/sources/pyside2/tests/pysidetest/CMakeLists.txt
@@ -143,6 +143,7 @@ PYSIDE_TEST(mixin_signal_slots_test.py)
 PYSIDE_TEST(modelview_test.py)
 PYSIDE_TEST(new_inherited_functions_test.py)
 PYSIDE_TEST(notify_id.py)
+PYSIDE_TEST(properties_test.py)
 PYSIDE_TEST(qapp_like_a_macro_test.py)
 PYSIDE_TEST(qvariant_test.py)
 PYSIDE_TEST(repr_test.py)
diff --git a/sources/pyside2/tests/pysidetest/properties_test.py b/sources/pyside2/tests/pysidetest/properties_test.py
new file mode 100644
index 00000000..cedfac8d
--- /dev/null
+++ b/sources/pyside2/tests/pysidetest/properties_test.py
@@ -0,0 +1,132 @@
+#############################################################################
+##
+## Copyright (C) 2020 The Qt Company Ltd.
+## Contact: https://www.qt.io/licensing/
+##
+## This file is part of the test suite of Qt for Python.
+##
+## $QT_BEGIN_LICENSE:GPL-EXCEPT$
+## Commercial License Usage
+## Licensees holding valid commercial Qt licenses may use this file in
+## accordance with the commercial license agreement provided with the
+## Software or, alternatively, in accordance with the terms contained in
+## a written agreement between you and The Qt Company. For licensing terms
+## and conditions see https://www.qt.io/terms-conditions. For further
+## information use the contact form at https://www.qt.io/contact-us.
+##
+## GNU General Public License Usage
+## Alternatively, this file may be used under the terms of the GNU
+## General Public License version 3 as published by the Free Software
+## Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
+## included in the packaging of this file. Please review the following
+## information to ensure the GNU General Public License requirements will
+## be met: https://www.gnu.org/licenses/gpl-3.0.html.
+##
+## $QT_END_LICENSE$
+##
+#############################################################################
+
+import os
+import sys
+import unittest
+
+sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
+from init_paths import init_test_paths
+init_test_paths(False)
+
+from PySide2.QtCore import QObject, QStringListModel, Signal, Property, Slot
+
+"""Tests PySide2.QtCore.Property()"""
+
+
+class TestObject(QObject):
+
+    valueChanged = Signal()
+
+    def __init__(self, parent=None):
+        super(TestObject, self).__init__(parent)
+        self._value = -1
+        self.valueChanged.connect(self._changed)
+        self.getter_called = 0
+        self.setter_called = 0
+        self.changed_emitted = 0
+
+    @Slot(int)
+    def _changed(self):
+        self.changed_emitted += 1
+
+    def getValue(self):
+        self.getter_called += 1
+        return self._value
+
+    def setValue(self, value):
+        self.setter_called += 1
+        if (self._value != value):
+            self._value = value
+            self.valueChanged.emit()
+
+    value = Property(int, fget=getValue, fset=setValue,
+                     notify=valueChanged)
+
+
+class TestDerivedObject(QStringListModel):
+
+    valueChanged = Signal()
+
+    def __init__(self, parent=None):
+        super(TestDerivedObject, self).__init__(parent)
+        self._value = -1
+        self.valueChanged.connect(self._changed)
+        self.getter_called = 0
+        self.setter_called = 0
+        self.changed_emitted = 0
+
+    @Slot(int)
+    def _changed(self):
+        self.changed_emitted += 1
+
+    def getValue(self):
+        self.getter_called += 1
+        return self._value
+
+    def setValue(self, value):
+        self.setter_called += 1
+        if (self._value != value):
+            self._value = value
+            self.valueChanged.emit()
+
+    value = Property(int, fget=getValue, fset=setValue,
+                     notify=valueChanged)
+
+
+class PropertyTest(unittest.TestCase):
+
+    def test1Object(self):
+        """Basic property test."""
+        testObject = TestObject()
+        v = testObject.value
+        self.assertEqual(v, -1)
+        self.assertEqual(testObject.getter_called, 1)
+        testObject.value = 42
+        v = testObject.value
+        self.assertEqual(v, 42)
+        self.assertEqual(testObject.changed_emitted, 1)
+        self.assertEqual(testObject.setter_called, 1)
+        self.assertEqual(testObject.getter_called, 2)
+
+    def test2DerivedObject(self):
+        """PYSIDE-1255: Run the same test for a class inheriting QObject."""
+        testObject = TestDerivedObject()
+        v = testObject.value
+        self.assertEqual(v, -1)
+        self.assertEqual(testObject.getter_called, 1)
+        testObject.value = 42
+        v = testObject.value
+        self.assertEqual(v, 42)
+        self.assertEqual(testObject.changed_emitted, 1)
+        self.assertEqual(testObject.setter_called, 1)
+        self.assertEqual(testObject.getter_called, 2)
+
+
+if __name__ == '__main__':
+    unittest.main()
diff --git a/sources/shiboken2/ApiExtractor/clangparser/compilersupport.cpp b/sources/shiboken2/ApiExtractor/clangparser/compilersupport.cpp
index d3e5e212..188725da 100644
--- a/sources/shiboken2/ApiExtractor/clangparser/compilersupport.cpp
+++ b/sources/shiboken2/ApiExtractor/clangparser/compilersupport.cpp
@@ -274,7 +274,7 @@ static QString findClangBuiltInIncludesDir()
         for (const QFileInfo &fi : versionDirs) {
             const QString fileName = fi.fileName();
             if (fileName.at(0).isDigit()) {
-                const QVersionNumber versionNumber = QVersionNumber::fromString(fileName.at(0));
+                const QVersionNumber versionNumber = QVersionNumber::fromString(fileName);
                 if (!versionNumber.isNull() && versionNumber > lastVersionNumber) {
                     candidate = fi.absoluteFilePath();
                     lastVersionNumber = versionNumber;
diff --git a/sources/shiboken2/ApiExtractor/typesystem.h b/sources/shiboken2/ApiExtractor/typesystem.h
index 8d8d60f3..4d0a23ca 100644
--- a/sources/shiboken2/ApiExtractor/typesystem.h
+++ b/sources/shiboken2/ApiExtractor/typesystem.h
@@ -1219,8 +1219,7 @@ class ComplexTypeEntry : public TypeEntry
 {
 public:
     enum TypeFlag {
-        Deprecated         = 0x4,
-        NoOverrideCaching  = 0x8
+        Deprecated         = 0x4
     };
     Q_DECLARE_FLAGS(TypeFlags, TypeFlag)
 
diff --git a/sources/shiboken2/ApiExtractor/typesystemparser.cpp b/sources/shiboken2/ApiExtractor/typesystemparser.cpp
index 5252ac00..0bb56f0f 100644
--- a/sources/shiboken2/ApiExtractor/typesystemparser.cpp
+++ b/sources/shiboken2/ApiExtractor/typesystemparser.cpp
@@ -60,7 +60,6 @@ static inline QString untilAttribute() { return QStringLiteral("until"); }
 static inline QString defaultSuperclassAttribute() { return QStringLiteral("default-superclass"); }
 static inline QString deleteInMainThreadAttribute() { return QStringLiteral("delete-in-main-thread"); }
 static inline QString deprecatedAttribute() { return QStringLiteral("deprecated"); }
-static inline QString noOverrideCachingAttribute() { return QStringLiteral("no-override-caching"); }
 static inline QString exceptionHandlingAttribute() { return QStringLiteral("exception-handling"); }
 static inline QString extensibleAttribute() { return QStringLiteral("extensible"); }
 static inline QString flagsAttribute() { return QStringLiteral("flags"); }
@@ -1477,9 +1476,6 @@ void TypeSystemParser::applyComplexTypeAttributes(const QXmlStreamReader &reader
         } else if (name == deprecatedAttribute()) {
             if (convertBoolean(attributes->takeAt(i).value(), deprecatedAttribute(), false))
                 ctype->setTypeFlags(ctype->typeFlags() | ComplexTypeEntry::Deprecated);
-       } else if (name == noOverrideCachingAttribute()) {
-            if (convertBoolean(attributes->takeAt(i).value(), noOverrideCachingAttribute(), false))
-                ctype->setTypeFlags(ctype->typeFlags() | ComplexTypeEntry::NoOverrideCaching);
         } else if (name == deleteInMainThreadAttribute()) {
             if (convertBoolean(attributes->takeAt(i).value(), deleteInMainThreadAttribute(), false))
                 ctype->setDeleteInMainThread(true);
diff --git a/sources/shiboken2/doc/gettingstarted.rst b/sources/shiboken2/doc/gettingstarted.rst
index e064cec5..caeb5a90 100644
--- a/sources/shiboken2/doc/gettingstarted.rst
+++ b/sources/shiboken2/doc/gettingstarted.rst
@@ -28,9 +28,9 @@ If you need only Shiboken Generator, a simple build run would look like this::
                             --build-tests \
                             --parallel=8 \
                             --verbose-build \
-                            --internal-build=shiboken2-generator
+                            --internal-build-type=shiboken2-generator
 
-The same can be used for the module, changing the value of ``internal-build`` to
+The same can be used for the module, changing the value of ``internal-build-type`` to
 ``shiboken2-module``.
 
 Using the wheels
diff --git a/sources/shiboken2/doc/typesystem_specifying_types.rst b/sources/shiboken2/doc/typesystem_specifying_types.rst
index 3ab6adbd..bca1e077 100644
--- a/sources/shiboken2/doc/typesystem_specifying_types.rst
+++ b/sources/shiboken2/doc/typesystem_specifying_types.rst
@@ -300,7 +300,6 @@ object-type
              allow-thread="..."
              exception-handling="..."
              hash-function="..."
-             no-override-caching="yes | no"
              stream="yes | no"
              revision="..." />
         </typesystem>
@@ -324,10 +323,6 @@ object-type
     specify the default handling for the corresponding function modification
     (see :ref:`modify-function`).
 
-    The *optional* attribute **no-override-caching** can be used to turn off the
-    caching of methods overridden in Python, which can trigger obscure bugs when
-    setting attributes in Python 2.
-
 interface-type
 ^^^^^^^^^^^^^^
 
diff --git a/sources/shiboken2/generator/shiboken2/shibokengenerator.cpp b/sources/shiboken2/generator/shiboken2/shibokengenerator.cpp
index fbd3c314..2cdb8870 100644
--- a/sources/shiboken2/generator/shiboken2/shibokengenerator.cpp
+++ b/sources/shiboken2/generator/shiboken2/shibokengenerator.cpp
@@ -2202,9 +2202,7 @@ bool ShibokenGenerator::injectedCodeUsesArgument(const AbstractMetaFunction *fun
 
 bool ShibokenGenerator::useOverrideCaching(const AbstractMetaClass *metaClass)
 {
-    return metaClass->isPolymorphic()
-        && !metaClass->typeEntry()->typeFlags().testFlag(ComplexTypeEntry::NoOverrideCaching);
-
+    return metaClass->isPolymorphic();
 }
 
 ShibokenGenerator::AttroCheck ShibokenGenerator::checkAttroFunctionNeeds(const AbstractMetaClass *metaClass) const
@@ -2219,6 +2217,13 @@ ShibokenGenerator::AttroCheck ShibokenGenerator::checkAttroFunctionNeeds(const A
             result |= AttroCheckFlag::SetattroQObject;
         if (useOverrideCaching(metaClass))
             result |= AttroCheckFlag::SetattroMethodOverride;
+        // PYSIDE-1255: If setattro is generated for a class inheriting
+        // QObject, the property code needs to be generated, too.
+        if ((result & AttroCheckFlag::SetattroMask) != 0
+            && !result.testFlag(AttroCheckFlag::SetattroQObject)
+            && metaClass->isQObject()) {
+            result |= AttroCheckFlag::SetattroQObject;
+        }
     }
     return result;
 }
diff --git a/sources/shiboken2/libshiboken/bufferprocs_py37.cpp b/sources/shiboken2/libshiboken/bufferprocs_py37.cpp
index ddb07390..da6bb00a 100644
--- a/sources/shiboken2/libshiboken/bufferprocs_py37.cpp
+++ b/sources/shiboken2/libshiboken/bufferprocs_py37.cpp
@@ -47,7 +47,7 @@
 
 #ifdef Py_LIMITED_API
 
-#include "pep384impl.h"
+#include "sbkpython.h"
 /* Buffer C-API for Python 3.0 */
 
 int
diff --git a/sources/shiboken2/libshiboken/pep384impl.cpp b/sources/shiboken2/libshiboken/pep384impl.cpp
index c7ca98c4..c04848eb 100644
--- a/sources/shiboken2/libshiboken/pep384impl.cpp
+++ b/sources/shiboken2/libshiboken/pep384impl.cpp
@@ -37,7 +37,7 @@
 **
 ****************************************************************************/
 
-#include "pep384impl.h"
+#include "sbkpython.h"
 #include "autodecref.h"
 #include "sbkstaticstrings.h"
 #include "sbkstaticstrings_p.h"
@@ -50,26 +50,19 @@ extern "C"
 /*
  * The documentation is located in pep384impl_doc.rst
  */
-
-/*****************************************************************************
- *
- * Support for object.h
- *
- */
-
+#if PY_VERSION_HEX < 0x03000000
+#define IS_PY2
+#endif // PY_VERSION_HEX < 0x03000000
 /*
  * Here is the verification code for PyTypeObject.
  * We create a type object and check if its fields
  * appear at the right offsets.
  */
+#ifdef Py_LIMITED_API
 
 #define make_dummy_int(x)   (x * sizeof(void *))
 #define make_dummy(x)       (reinterpret_cast<void *>(make_dummy_int(x)))
 
-#ifdef Py_LIMITED_API
-datetime_struc *PyDateTimeAPI = NULL;
-#endif
-
 static PyObject *
 dummy_func(PyObject * /* self */, PyObject * /* args */)
 {
@@ -180,18 +173,18 @@ check_PyTypeObject_valid()
     Py_DECREF(probe_tp_mro);
 }
 
-
-#ifdef Py_LIMITED_API
-
 #if PY_VERSION_HEX < PY_ISSUE33738_SOLVED
 #include "pep384_issue33738.cpp"
 #endif
 
+#endif // Py_LIMITED_API
+
 /*****************************************************************************
  *
  * Support for unicodeobject.h
  *
  */
+#ifdef Py_LIMITED_API
 
 char *
 _PepUnicode_AsString(PyObject *str)
@@ -207,15 +200,15 @@ _PepUnicode_AsString(PyObject *str)
 #define TOSTRING(x) STRINGIFY(x)
 #define AT __FILE__ ":" TOSTRING(__LINE__)
 
-    static PyObject *cstring_dict = NULL;
-    if (cstring_dict == NULL) {
+    static PyObject *cstring_dict = nullptr;
+    if (cstring_dict == nullptr) {
         cstring_dict = PyDict_New();
-        if (cstring_dict == NULL)
+        if (cstring_dict == nullptr)
             Py_FatalError("Error in " AT);
     }
-    PyObject *bytesStr = PyUnicode_AsEncodedString(str, "utf8", NULL);
-    PyObject *entry = PyDict_GetItem(cstring_dict, bytesStr);
-    if (entry == NULL) {
+    PyObject *bytesStr = PyUnicode_AsEncodedString(str, "utf8", nullptr);
+    PyObject *entry = PyDict_GetItemWithError(cstring_dict, bytesStr);
+    if (entry == nullptr) {
         int e = PyDict_SetItem(cstring_dict, bytesStr, bytesStr);
         if (e != 0)
             Py_FatalError("Error in " AT);
@@ -225,12 +218,14 @@ _PepUnicode_AsString(PyObject *str)
         Py_DECREF(bytesStr);
     return PyBytes_AsString(entry);
 }
+#endif // Py_LIMITED_API
 
 /*****************************************************************************
  *
  * Support for longobject.h
  *
  */
+#ifdef Py_LIMITED_API
 
 /*
  * This is the original Python function _PyLong_AsInt() from longobject.c .
@@ -253,15 +248,18 @@ _PepLong_AsInt(PyObject *obj)
                         "Python int too large to convert to C int");
         return -1;
     }
-    return (int)result;
+    return int(result);
 }
+#endif // Py_LIMITED_API
 
 /*****************************************************************************
  *
  * Support for pydebug.h
  *
  */
-static PyObject *sys_flags = NULL;
+#ifdef Py_LIMITED_API
+
+static PyObject *sys_flags = nullptr;
 
 int
 Pep_GetFlag(const char *name)
@@ -271,13 +269,13 @@ Pep_GetFlag(const char *name)
 
     if (!initialized) {
         sys_flags = PySys_GetObject("flags");
-        // func gives no error if NULL is returned and does not incref.
+        // func gives no error if nullptr is returned and does not incref.
         Py_XINCREF(sys_flags);
         initialized = 1;
     }
-    if (sys_flags != NULL) {
+    if (sys_flags != nullptr) {
         PyObject *ob_ret = PyObject_GetAttrString(sys_flags, name);
-        if (ob_ret != NULL) {
+        if (ob_ret != nullptr) {
             long long_ret = PyLong_AsLong(ob_ret);
             Py_DECREF(ob_ret);
             ret = (int) long_ret;
@@ -299,12 +297,14 @@ Pep_GetVerboseFlag()
     }
     return verbose_flag;
 }
+#endif // Py_LIMITED_API
 
 /*****************************************************************************
  *
  * Support for code.h
  *
  */
+#ifdef Py_LIMITED_API
 
 int
 PepCode_Get(PyCodeObject *co, const char *name)
@@ -314,28 +314,32 @@ PepCode_Get(PyCodeObject *co, const char *name)
     int ret = -1;
 
     ob_ret = PyObject_GetAttrString(ob, name);
-    if (ob_ret != NULL) {
+    if (ob_ret != nullptr) {
         long long_ret = PyLong_AsLong(ob_ret);
         Py_DECREF(ob_ret);
         ret = (int) long_ret;
     }
     return ret;
 }
+#endif // Py_LIMITED_API
 
 /*****************************************************************************
  *
  * Support for datetime.h
  *
  */
+#ifdef Py_LIMITED_API
+
+datetime_struc *PyDateTimeAPI = nullptr;
 
 static PyTypeObject *dt_getCheck(const char *name)
 {
     PyObject *op = PyObject_GetAttrString(PyDateTimeAPI->module, name);
-    if (op == NULL) {
+    if (op == nullptr) {
         fprintf(stderr, "datetime.%s not found\n", name);
         Py_FatalError("aborting");
     }
-    return (PyTypeObject *)op;
+    return reinterpret_cast<PyTypeObject *>(op);
 }
 
 // init_DateTime is called earlier than our module init.
@@ -346,10 +350,10 @@ init_DateTime(void)
     static int initialized = 0;
     if (!initialized) {
         PyDateTimeAPI = (datetime_struc *)malloc(sizeof(datetime_struc));
-        if (PyDateTimeAPI == NULL)
+        if (PyDateTimeAPI == nullptr)
             Py_FatalError("PyDateTimeAPI malloc error, aborting");
         PyDateTimeAPI->module = PyImport_ImportModule("datetime");
-        if (PyDateTimeAPI->module == NULL)
+        if (PyDateTimeAPI->module == nullptr)
             Py_FatalError("datetime module not found, aborting");
         PyDateTimeAPI->DateType     = dt_getCheck("date");
         PyDateTimeAPI->DateTimeType = dt_getCheck("datetime");
@@ -368,7 +372,7 @@ PyDateTime_Get(PyObject *ob, const char *name)
     int ret = -1;
 
     ob_ret = PyObject_GetAttrString(ob, name);
-    if (ob_ret != NULL) {
+    if (ob_ret != nullptr) {
         long long_ret = PyLong_AsLong(ob_ret);
         Py_DECREF(ob_ret);
         ret = (int) long_ret;
@@ -398,21 +402,23 @@ PyTime_FromTime(int hour, int min, int sec, int usec)
     return PyObject_CallFunction((PyObject *)PyDateTimeAPI->TimeType,
                                  (char *)"(iiii)", hour, min, sec, usec);
 }
+#endif // Py_LIMITED_API
 
 /*****************************************************************************
  *
  * Support for pythonrun.h
  *
  */
+#ifdef Py_LIMITED_API
 
 // Flags are ignored in these simple helpers.
 PyObject *
 PyRun_String(const char *str, int start, PyObject *globals, PyObject *locals)
 {
     PyObject *code = Py_CompileString(str, "pyscript", start);
-    PyObject *ret = NULL;
+    PyObject *ret = nullptr;
 
-    if (code != NULL) {
+    if (code != nullptr) {
         ret = PyEval_EvalCode(code, globals, locals);
     }
     Py_XDECREF(code);
@@ -423,9 +429,9 @@ PyRun_String(const char *str, int start, PyObject *globals, PyObject *locals)
 
 // This is only a simple local helper that returns a computed variable.
 // Used also in Python 2.
-#if defined(Py_LIMITED_API) || PY_VERSION_HEX < 0x03000000
+#if defined(Py_LIMITED_API) || defined(IS_PY2)
 static PyObject *
-PepRun_GetResult(const char *command, const char *resvar)
+PepRun_GetResult(const char *command)
 {
     PyObject *d, *v, *res;
 
@@ -435,30 +441,29 @@ PepRun_GetResult(const char *command, const char *resvar)
         return nullptr;
     }
     v = PyRun_String(command, Py_file_input, d, d);
-    res = v ? PyDict_GetItemString(d, resvar) : NULL;
+    res = v ? PyDict_GetItem(d, Shiboken::PyName::result()) : nullptr;
     Py_XDECREF(v);
     Py_DECREF(d);
     return res;
 }
-#endif // Py_LIMITED_API || Python 2
-
-#ifdef Py_LIMITED_API
+#endif // defined(Py_LIMITED_API) || defined(IS_PY2)
 
 /*****************************************************************************
  *
  * Support for classobject.h
  *
  */
+#ifdef Py_LIMITED_API
 
-PyTypeObject *PepMethod_TypePtr = NULL;
+PyTypeObject *PepMethod_TypePtr = nullptr;
 
 static PyTypeObject *getMethodType(void)
 {
     static const char prog[] =
         "class _C:\n"
         "    def _m(self): pass\n"
-        "MethodType = type(_C()._m)\n";
-    return (PyTypeObject *) PepRun_GetResult(prog, "MethodType");
+        "result = type(_C()._m)\n";
+    return reinterpret_cast<PyTypeObject *>(PepRun_GetResult(prog));
 }
 
 // We have no access to PyMethod_New and must call types.MethodType, instead.
@@ -489,12 +494,14 @@ PyMethod_Self(PyObject *im)
     Py_DECREF(ret);
     return ret;
 }
+#endif // Py_LIMITED_API
 
 /*****************************************************************************
  *
  * Support for funcobject.h
  *
  */
+#ifdef Py_LIMITED_API
 
 PyObject *
 PepFunction_Get(PyObject *ob, const char *name)
@@ -509,22 +516,64 @@ PepFunction_Get(PyObject *ob, const char *name)
 
 // This became necessary after Windows was activated.
 
-PyTypeObject *PepFunction_TypePtr = NULL;
+PyTypeObject *PepFunction_TypePtr = nullptr;
 
 static PyTypeObject *getFunctionType(void)
 {
     static const char prog[] =
-        "from types import FunctionType\n";
-    return (PyTypeObject *) PepRun_GetResult(prog, "FunctionType");
+        "from types import FunctionType as result\n";
+    return reinterpret_cast<PyTypeObject *>(PepRun_GetResult(prog));
 }
+#endif // Py_LIMITED_API || Python 2
+
+/*****************************************************************************
+ *
+ * Support for dictobject.h
+ *
+ */
+
+// PYSIDE-803, PYSIDE-813: We need that GIL-free version from Python 2.7.12 .
+#ifdef IS_PY2
+
+/* Variant of PyDict_GetItem() that doesn't suppress exceptions.
+   This returns NULL *with* an exception set if an exception occurred.
+   It returns NULL *without* an exception set if the key wasn't present.
+*/
+PyObject *
+PyDict_GetItemWithError(PyObject *op, PyObject *key)
+{
+    long hash;
+    PyDictObject *mp = reinterpret_cast<PyDictObject *>(op);
+    PyDictEntry *ep;
+    if (!PyDict_Check(op)) {
+        PyErr_BadInternalCall();
+        return nullptr;
+    }
+    if (!PyString_CheckExact(key) ||
+        (hash = (reinterpret_cast<PyStringObject *>(key))->ob_shash) == -1)
+    {
+        hash = PyObject_Hash(key);
+        if (hash == -1) {
+            return nullptr;
+        }
+    }
+
+    ep = (mp->ma_lookup)(mp, key, hash);
+    if (ep == nullptr) {
+        return nullptr;
+    }
+    return ep->me_value;
+}
+#endif // IS_PY2
 
 /*****************************************************************************
  *
  * Extra support for signature.cpp
  *
  */
+#ifdef Py_LIMITED_API
 
-PyTypeObject *PepStaticMethod_TypePtr = NULL;
+PyTypeObject *PepStaticMethod_TypePtr = nullptr;
 
 static PyTypeObject *
 getStaticMethodType(void)
@@ -533,8 +582,8 @@ getStaticMethodType(void)
     //    "StaticMethodType = type(str.__dict__['maketrans'])\n";
     static const char prog[] =
         "from xxsubtype import spamlist\n"
-        "StaticMethod_Type = type(spamlist.__dict__['staticmeth'])\n";
-    return (PyTypeObject *) PepRun_GetResult(prog, "StaticMethod_Type");
+        "result = type(spamlist.__dict__['staticmeth'])\n";
+    return reinterpret_cast<PyTypeObject *>(PepRun_GetResult(prog));
 }
 
 typedef struct {
@@ -548,25 +597,25 @@ PyStaticMethod_New(PyObject *callable)
 {
     staticmethod *sm = (staticmethod *)
         PyType_GenericAlloc(PepStaticMethod_TypePtr, 0);
-    if (sm != NULL) {
+    if (sm != nullptr) {
         Py_INCREF(callable);
         sm->sm_callable = callable;
     }
-    return (PyObject *)sm;
+    return reinterpret_cast<PyObject *>(sm);
 }
 #endif // Py_LIMITED_API
 
-#if PY_VERSION_HEX < 0x03000000
-PyTypeObject *PepMethodDescr_TypePtr = NULL;
+#ifdef IS_PY2
+PyTypeObject *PepMethodDescr_TypePtr = nullptr;
 
 static PyTypeObject *
 getMethodDescrType(void)
 {
     static const char prog[] =
-        "MethodDescr_Type = type(str.split)\n";
-    return (PyTypeObject *) PepRun_GetResult(prog, "MethodDescr_Type");
+        "result = type(str.split)\n";
+    return reinterpret_cast<PyTypeObject *>(PepRun_GetResult(prog));
 }
-#endif
+#endif // IS_PY2
 
 /*****************************************************************************
  *
@@ -595,9 +644,9 @@ PepType_GetNameStr(PyTypeObject *type)
 
 #ifdef Py_LIMITED_API
 // We keep these definitions local, because they don't work in Python 2.
-#define PyUnicode_GET_LENGTH(op)    PyUnicode_GetLength((PyObject *)(op))
-#define PyUnicode_READ_CHAR(u, i)   PyUnicode_ReadChar((PyObject *)(u), (i))
-#endif
+# define PyUnicode_GET_LENGTH(op)    PyUnicode_GetLength((PyObject *)(op))
+# define PyUnicode_READ_CHAR(u, i)   PyUnicode_ReadChar((PyObject *)(u), (i))
+#endif // Py_LIMITED_API
 
 PyObject *
 _Pep_PrivateMangle(PyObject *self, PyObject *name)
@@ -607,9 +656,9 @@ _Pep_PrivateMangle(PyObject *self, PyObject *name)
      * This function is modelled after _Py_Mangle, but is optimized
      * a little for our purpose.
      */
-#if PY_VERSION_HEX < 0X03000000
+#ifdef IS_PY2
     const char *namestr = PyString_AsString(name);
-    if (namestr == NULL || namestr[0] != '_' || namestr[1] != '_') {
+    if (namestr == nullptr || namestr[0] != '_' || namestr[1] != '_') {
         Py_INCREF(name);
         return name;
     }
@@ -634,7 +683,7 @@ _Pep_PrivateMangle(PyObject *self, PyObject *name)
         Py_INCREF(name);
         return name;
     }
-#endif
+#endif // IS_PY2
     Shiboken::AutoDecRef privateobj(PyObject_GetAttr(
         reinterpret_cast<PyObject *>(Py_TYPE(self)), Shiboken::PyMagicName::name()));
 #ifndef Py_LIMITED_API
@@ -655,7 +704,7 @@ _Pep_PrivateMangle(PyObject *self, PyObject *name)
     if (plen + nlen >= PY_SSIZE_T_MAX - 1) {
         PyErr_SetString(PyExc_OverflowError,
                         "private identifier too large to be mangled");
-        return NULL;
+        return nullptr;
     }
     size_t const amount = ipriv + 1 + plen + nlen;
     size_t const big_stack = 1000;
@@ -673,7 +722,7 @@ _Pep_PrivateMangle(PyObject *self, PyObject *name)
     if (amount > big_stack)
         free(resbuf);
     return result;
-#endif  // Py_LIMITED_API
+#endif // else Py_LIMITED_API
 }
 
 /*****************************************************************************
@@ -704,17 +753,18 @@ init_PepRuntime()
 void
 Pep384_Init()
 {
-    check_PyTypeObject_valid();
     init_PepRuntime();
 #ifdef Py_LIMITED_API
+    check_PyTypeObject_valid();
     Pep_GetVerboseFlag();
     PepMethod_TypePtr = getMethodType();
     PepFunction_TypePtr = getFunctionType();
     PepStaticMethod_TypePtr = getStaticMethodType();
-#endif
-#if PY_VERSION_HEX < 0x03000000
+#endif // Py_LIMITED_API
+
+#ifdef IS_PY2
     PepMethodDescr_TypePtr = getMethodDescrType();
-#endif
+#endif // IS_PY2
 }
 
 } // extern "C"
diff --git a/sources/shiboken2/libshiboken/pep384impl.h b/sources/shiboken2/libshiboken/pep384impl.h
index 6d0fa245..e735095e 100644
--- a/sources/shiboken2/libshiboken/pep384impl.h
+++ b/sources/shiboken2/libshiboken/pep384impl.h
@@ -40,8 +40,6 @@
 #ifndef PEP384IMPL_H
 #define PEP384IMPL_H
 
-#include "sbkpython.h"
-
 extern "C"
 {
 
@@ -204,17 +202,36 @@ LIBSHIBOKEN_API int Pep_GetVerboseFlag(void);
  * RESOLVED: unicodeobject.h
  *
  */
-#ifdef Py_LIMITED_API
-
-LIBSHIBOKEN_API char *_PepUnicode_AsString(PyObject *);
 
+///////////////////////////////////////////////////////////////////////
+//
+// PYSIDE-813: About The Length Of Unicode Objects
+// -----------------------------------------------
+//
+// In Python 2 and before Python 3.3, the macro PyUnicode_GET_SIZE
+// worked fine and really like a macro.
+//
+// Meanwhile, the unicode objects have changed their layout very much,
+// and the former cheap macro call has become a real function call
+// that converts objects and needs PyMemory.
+//
+// That is not only inefficient, but also requires the GIL!
+// This problem was visible by debug Python and qdatastream_test.py .
+// It was found while fixing the refcount problem of PYSIDE-813 which
+// needed a debug Python.
+//
+
+// PyUnicode_GetSize is deprecated in favor of PyUnicode_GetLength.
 #if PY_VERSION_HEX < 0x03000000
-#define PyUnicode_GET_SIZE(op)      PyUnicode_GetSize((PyObject *)(op))
+#define PepUnicode_GetLength(op)    PyUnicode_GetSize((PyObject *)(op))
 #else
-// PyUnicode_GetSize is deprecated in favor of PyUnicode_GetLength
-#define PyUnicode_GET_SIZE(op)      PyUnicode_GetLength((PyObject *)(op))
+#define PepUnicode_GetLength(op)    PyUnicode_GetLength((PyObject *)(op))
 #endif
 
+#ifdef Py_LIMITED_API
+
+LIBSHIBOKEN_API char *_PepUnicode_AsString(PyObject *);
+
 #else
 #define _PepUnicode_AsString     PyUnicode_AsUTF8
 #endif
@@ -260,6 +277,17 @@ LIBSHIBOKEN_API char *_PepUnicode_AsString(PyObject *);
 #define PyList_GET_SIZE(op)         PyList_Size(op)
 #endif
 
+/*****************************************************************************
+ *
+ * RESOLVED: dictobject.h
+ *
+ * PYSIDE-803, PYSIDE-813: We need PyDict_GetItemWithError in order to
+ *                         avoid the GIL.
+ */
+#if PY_VERSION_HEX < 0x03000000
+LIBSHIBOKEN_API PyObject *PyDict_GetItemWithError(PyObject *mp, PyObject *key);
+#endif
+
 /*****************************************************************************
  *
  * RESOLVED: methodobject.h
diff --git a/sources/shiboken2/libshiboken/pep384impl_doc.rst b/sources/shiboken2/libshiboken/pep384impl_doc.rst
index 2f3b7ea9..d8ebdbe7 100644
--- a/sources/shiboken2/libshiboken/pep384impl_doc.rst
+++ b/sources/shiboken2/libshiboken/pep384impl_doc.rst
@@ -70,8 +70,10 @@ supported. We redefined it as macro ``Py_VerboseFlag`` which calls ``Pep_Verbose
 unicodeobject.h
 ---------------
 
-The macro ``PyUnicode_GET_SIZE`` was redefined to call into ``PyUnicode_GetSize``
-for Python 2, and ``PyUnicode_GetLength`` for Python 3.
+The macro ``PyUnicode_GET_SIZE`` was removed and replaced by ``PepUnicode_GetLength``
+which evaluates to ``PyUnicode_GetSize`` for Python 2 and ``PyUnicode_GetLength`` for Python 3.
+Since Python 3.3, ``PyUnicode_GetSize`` would have the bad side effect of requiring the GIL!
+
 Function ``_PyUnicode_AsString`` is unavailable and was replaced by a macro
 that calls ``_PepUnicode_AsString``. The implementation was a bit involved,
 and it would be better to change the code and replace this function.
@@ -104,6 +106,16 @@ listobject.h
 function calls.
 
 
+dictobject.h
+------------
+
+``PyDict_GetItem`` also exists in a ``PyDict_GetItemWithError`` version that does
+not suppress errors. This suppression has the side effect of touching global
+structures. This function exists in Python 2 only since Python 2.7.12 and has
+a different name. We simply implemented the function.
+Needed to avoid the GIL when accessing dictionaries.
+
+
 methodobject.h
 --------------
 
diff --git a/sources/shiboken2/libshiboken/sbkpython.h b/sources/shiboken2/libshiboken/sbkpython.h
index f06b0b19..9dd1e712 100644
--- a/sources/shiboken2/libshiboken/sbkpython.h
+++ b/sources/shiboken2/libshiboken/sbkpython.h
@@ -72,6 +72,7 @@ extern "C" {
 // Now we have the usual variables from Python.h .
 #  include "python25compat.h"
 #  include "shibokenmacros.h"
+// "pep384impl.h" may nowhere be included but in this file.
 #  include "pep384impl.h"
 #  include "typespec.h"
 #  pragma pop_macro("slots")
@@ -98,6 +99,7 @@ extern "C" {
 // Now we have the usual variables from Python.h .
 #  include "python25compat.h"
 #  include "shibokenmacros.h"
+// "pep384impl.h" may nowhere be included but in this file.
 #  include "pep384impl.h"
 #  include "typespec.h"
 #endif
diff --git a/sources/shiboken2/libshiboken/sbkstaticstrings.cpp b/sources/shiboken2/libshiboken/sbkstaticstrings.cpp
index 42d20d13..04069a4d 100644
--- a/sources/shiboken2/libshiboken/sbkstaticstrings.cpp
+++ b/sources/shiboken2/libshiboken/sbkstaticstrings.cpp
@@ -54,6 +54,7 @@ namespace PyName {
 // exported:
 STATIC_STRING_IMPL(dumps, "dumps")
 STATIC_STRING_IMPL(loads, "loads")
+STATIC_STRING_IMPL(result, "result")
 
 // Internal:
 STATIC_STRING_IMPL(classmethod, "classmethod")
diff --git a/sources/shiboken2/libshiboken/sbkstaticstrings.h b/sources/shiboken2/libshiboken/sbkstaticstrings.h
index fa21a8e2..6016fe10 100644
--- a/sources/shiboken2/libshiboken/sbkstaticstrings.h
+++ b/sources/shiboken2/libshiboken/sbkstaticstrings.h
@@ -50,6 +50,7 @@ namespace PyName
 {
 LIBSHIBOKEN_API PyObject *dumps();
 LIBSHIBOKEN_API PyObject *loads();
+LIBSHIBOKEN_API PyObject *result();
 } // namespace PyName
 
 namespace PyMagicName
diff --git a/sources/shiboken2/libshiboken/sbkstring.cpp b/sources/shiboken2/libshiboken/sbkstring.cpp
index 4a441222..38bb105d 100644
--- a/sources/shiboken2/libshiboken/sbkstring.cpp
+++ b/sources/shiboken2/libshiboken/sbkstring.cpp
@@ -202,7 +202,7 @@ Py_ssize_t len(PyObject *str)
         return 0;
 
     if (PyUnicode_Check(str))
-        return PyUnicode_GET_SIZE(str);
+        return PepUnicode_GetLength(str);
 
     if (PyBytes_Check(str))
         return PyBytes_GET_SIZE(str);
diff --git a/sources/shiboken2/shiboken_version.py b/sources/shiboken2/shiboken_version.py
index 53ec8336..fc04d00a 100644
--- a/sources/shiboken2/shiboken_version.py
+++ b/sources/shiboken2/shiboken_version.py
@@ -39,7 +39,7 @@
 
 major_version = "5"
 minor_version = "14"
-patch_version = "2"
+patch_version = "2.1"
 
 # For example: "a", "b", "rc"
 # (which means "alpha", "beta", "release candidate").
